While defining new constructor for classes extended from uvm_transaction/uvm_sequence_item we don't need to add uvm_component parent = null &
super.new(name , parent) instead string name = "name" & super.new(name) while defining the constructor will be fine.

Also in the checker if I am defining some analysis import - then try to define it like "from_analysis_port_name". This will give idea about from where the transactor
or packet is coming rather than explicitly checking in the env file.

//UVM phases and usecase
  1. Build - Build_phase is built by top-down approach. It is used to construct sub-components right from Testcase
  2. Connect - Connect phase is built in bottom-up approach.
  3. End of elaboration - This phase also executes in bottom-up approach.
  4. Start of simulation - This phase also executes in bottom-up approach.
  5. Run - It is time consuming task. Run task are executed in parallel. Drivers & monitors should just use run_phase.
    a. pre_reset
    b. Reset
    c. post_reset
    d. pre_configure
    e. Configure
    f. post_configure
    g. pre_main
    h. Main
    i. post_main
    j. pre_shutdown
    k. Shutdown
    l. post_shutdown
  6. Extract -  Follows bottom-up approach. It retrieves and processes information from scoreboards and functional coverage monitors.
  7. Check - Follows bottom-up approach. It checks if the DUT behaved correctly and identifies errors that may have occurred during the execution.
  8. Report - Follows bottom-up approach. It displays the result of the simulation.
  9. Final - Follows top-down approach. It completes any other outstanding actions.
  
  In tb_top.sv run_test() is called to start the uvm_phase
  At t =0 The first 4 phase get executed 1 after the other.
  Now run_phase starts. And let say the complete simulation takes 10,000ns
  At 10,00ns the remaining 4 phases get executed.
  
  In our tb we may use different calculation across different files but since the use case of uvm phases is to have common synchronization across our env.
  We can also use Phase objection.raised and dropped to wait for a specific code to complete and letting uvm phase to reach next state.
  Components and Objects can raise and drop objections. It remains in the same phase till all the objections are dropped
  For Components - 
    Phase.raise_objection(this);
    Phase.drop_objection(this);
  For Objects -
    Starting_phase.raise_objection(this);
    Starting_phase.drop_objection(this);
  A task is time consuming whereas a function gets executed in 0 time
  
  What is phase domains or jumping - With the use of phase domain, each component can complete independent of other components. No synchronization is required.
  
  UVM_INFO format- UVM_INFO file_path/filepath/line-num time scope id "message"

  TLM stands for Transaction Level Modeling. TLM promotes reuse as they have same interface
  
  //Config db set and get
  uvm_config_db #(int )::set(this, "*", "fw_cfg", fw_cfg);
 
  if(!uvm_config_db#(int)::get(this,"", "fw_cfg", fw_cfg1);
    `uvm_fatal("FATAL", "Didn't get fw_cfg variable")
  
  //Config fb set and get when component has a paarmeter of type class
  uvm_config_db#(class test_sequence)::set(this, "*", "sequence_test" test_seq);
  
  
  
  //Config fb set and get when component has no parameter
  uvm_config_db::set(this,"*","comp_with_no_param", test_comp_param);
  
  
  
  //Config db set and get in case of virtual interface
